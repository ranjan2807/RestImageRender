//
//  RestClient.swift
//  RestImageRender
//
//  Copyright Â© 2020 Ranjan-iOS. All rights reserved.
//

import Foundation
import Alamofire
import RxSwift

/// Rest client protocol for handling data requests
protocol RestClientProtocol {
	/// Handles data requests from the remote
	/// - Parameter url: remote url of data
	func fetchData (url: String) -> Observable<AppData>
}

struct RestClient: RestClientProtocol {

	func fetchData (url: String) -> Observable<AppData> {
		return Observable.create { observer in
			// checks if network connectivity is available
			// if not, it completes the observable by passing a network error
			if !NetworkReachabilityManager()!.isReachable {
				observer.onError(RIRError.factory.noNetworkError())
				return Disposables.create ()
			}

			// starts the connection to fetch data from url
			DispatchQueue.global().async {
				AF.request(
					url
				).validate()
					.responseJSON { response in

						// check response object
						guard let responseTemp = response.response else {
							observer.onError(self.handleError(response: response))
							return
						}

						// check status code
						if responseTemp.statusCode < 200,
							responseTemp.statusCode > 300 {
							observer.onError(self.handleError(response: response))
							return
						}

						// check response data
						guard let data = response.data else {
							observer.onError(self.handleError(response: response))
							return
						}

						// update encoding of received data
						let stringValue = String(decoding: data, as: UTF8.self)
						let dataTemp = Data(stringValue.utf8)

						do {
							// forward received data in observable next
							let appData = try JSONDecoder().decode(
								AppData.self,
								from: dataTemp)
							observer.onNext(appData)

							// dispose the observable as task is completed
							observer.onCompleted()

						} catch {
							// fire parsing error to observable
							observer.onError(RIRError.factory.jsonParsingError())
						}
				}
			}

			return Disposables.create ()
		}
	}

	/// Read error in response and returns an error object
	/// - Parameter response: response received from data request
	private func handleError(response: AFDataResponse<Any>) -> RIRError {
		if let errorTemp = response.error,
			let errDesc = errorTemp.errorDescription {
			return RIRError.factory.customError(domain: errDesc)
		} else {
			return RIRError.factory.customError()
		}
	}
}

extension RestClient: ImageProcessStrategyProtocol {

	func fetchImage (url: String) -> Observable<Data> {
		return Observable.create { observer in
			// checks if network connectivity is available
			// if not, it completes the observable by passing a network error
			if !NetworkReachabilityManager()!.isReachable {
				observer.onError(RIRError.factory.noNetworkError())
				return Disposables.create ()
			}

			// starts the connection to download data from url
			DispatchQueue.global().async {
				AF.download(url).responseData { (response) in

					// check response object
					guard let responseTemp = response.response else {
						observer.onError(self.handleDownloadError(response: response))
						return
					}

					// check status code
					if responseTemp.statusCode < 200,
						responseTemp.statusCode > 300 {
						observer.onError(self.handleDownloadError(response: response))
						return
					}

					// check file url is available
					guard let fileUrl = response.fileURL else {
						observer.onError(self.handleDownloadError(response: response))
						return
					}

					do {
						// retreive data from temp downloaded file
						let data = try Data(contentsOf: fileUrl)

						// save the file to document directory to cache it later
						DispatchQueue.global().async {
							FileOperations.saveFileForUrl(remoteUrl: url, fileData: data)
						}

						// got the image data
						observer.onNext(data)

						// finish up the observables
						observer.onCompleted()
					} catch {
						if let errorTemp = response.error,
							let errDesc = errorTemp.errorDescription {
							observer.onError(RIRError.factory.customError(domain: errDesc))
						} else {
							observer.onError(RIRError.factory.customError())
						}
						return
					}

					DispatchQueue.global().async {
						// space management by removing temp file generated by url request
						do {
							try FileManager.default.removeItem(at: fileUrl)
						} catch {
							print("deleted successfully --> \(fileUrl.absoluteString)")
						}

					}
				}
			}

			return Disposables.create()
		}
	}

	/// Read error in response and returns an error object
	/// - Parameter response: response received from data request
	private func handleDownloadError(response: AFDownloadResponse<Data>) -> RIRError {
		if let errorTemp = response.error,
			let errDesc = errorTemp.errorDescription {
			return RIRError.factory.customError(domain: errDesc)
		} else {
			return RIRError.factory.customError()
		}
	}
}
